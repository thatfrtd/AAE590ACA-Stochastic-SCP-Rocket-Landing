
"""
Auto-generated by CVXPYgen on June 13, 2025 at 10:35:46.
Content: Custom solve method for CVXPY interface.
"""

import time
import warnings
import numpy as np
from cvxpy.reductions import Solution
from cvxpy.problems.problem import SolverStats
from Deterministic_3DoF_FOH_PTR_QOCO2 import cpg_module


standard_settings_names = {}


def squeeze_scalar(val):
    if isinstance(val, np.ndarray):
        val = val.squeeze()
        if val.shape == ():
            return val.item()
    return val


def cpg_solve(prob, updated_params=None, **kwargs):

    # set flags for updated parameters
    upd = cpg_module.cpg_updated()
    if updated_params is None:
        updated_params = ["Ak_0", "Bk_minus_0", "Bk_plus_0", "ck", "Ak_1", "Bk_minus_1", "Bk_plus_1", "Ak_2", "Bk_minus_2", "Bk_plus_2", "Ak_3", "Bk_minus_3", "Bk_plus_3", "Ak_4", "Bk_minus_4", "Bk_plus_4", "Ak_5", "Bk_minus_5", "Bk_plus_5", "Ak_6", "Bk_minus_6", "Bk_plus_6", "Ak_7", "Bk_minus_7", "Bk_plus_7", "Ak_8", "Bk_minus_8", "Bk_plus_8", "Ak_9", "Bk_minus_9", "Bk_plus_9", "Ak_10", "Bk_minus_10", "Bk_plus_10", "Ak_11", "Bk_minus_11", "Bk_plus_11", "Ak_12", "Bk_minus_12", "Bk_plus_12", "Ak_13", "Bk_minus_13", "Bk_plus_13", "x_0", "x_ref", "u_ref"]
    for p in updated_params:
        try:
            setattr(upd, p, True)
        except AttributeError:
            raise AttributeError(f"{p} is not a parameter.")

    # set solver settings
    cpg_module.set_solver_default_settings()
    for key, value in kwargs.items():
        try:
            eval(f'cpg_module.set_solver_{standard_settings_names.get(key, key)}(value)')
        except AttributeError:
            raise AttributeError(f'Solver setting "{key}" not available.')

    # set parameter values
    par = cpg_module.cpg_params()
    param_dict = prob.param_dict
    par.Ak_0 = list(param_dict["Ak_0"].value.flatten(order="F"))
    par.Bk_minus_0 = list(param_dict["Bk_minus_0"].value.flatten(order="F"))
    par.Bk_plus_0 = list(param_dict["Bk_plus_0"].value.flatten(order="F"))
    par.ck = list(param_dict["ck"].value.flatten(order="F"))
    par.Ak_1 = list(param_dict["Ak_1"].value.flatten(order="F"))
    par.Bk_minus_1 = list(param_dict["Bk_minus_1"].value.flatten(order="F"))
    par.Bk_plus_1 = list(param_dict["Bk_plus_1"].value.flatten(order="F"))
    par.Ak_2 = list(param_dict["Ak_2"].value.flatten(order="F"))
    par.Bk_minus_2 = list(param_dict["Bk_minus_2"].value.flatten(order="F"))
    par.Bk_plus_2 = list(param_dict["Bk_plus_2"].value.flatten(order="F"))
    par.Ak_3 = list(param_dict["Ak_3"].value.flatten(order="F"))
    par.Bk_minus_3 = list(param_dict["Bk_minus_3"].value.flatten(order="F"))
    par.Bk_plus_3 = list(param_dict["Bk_plus_3"].value.flatten(order="F"))
    par.Ak_4 = list(param_dict["Ak_4"].value.flatten(order="F"))
    par.Bk_minus_4 = list(param_dict["Bk_minus_4"].value.flatten(order="F"))
    par.Bk_plus_4 = list(param_dict["Bk_plus_4"].value.flatten(order="F"))
    par.Ak_5 = list(param_dict["Ak_5"].value.flatten(order="F"))
    par.Bk_minus_5 = list(param_dict["Bk_minus_5"].value.flatten(order="F"))
    par.Bk_plus_5 = list(param_dict["Bk_plus_5"].value.flatten(order="F"))
    par.Ak_6 = list(param_dict["Ak_6"].value.flatten(order="F"))
    par.Bk_minus_6 = list(param_dict["Bk_minus_6"].value.flatten(order="F"))
    par.Bk_plus_6 = list(param_dict["Bk_plus_6"].value.flatten(order="F"))
    par.Ak_7 = list(param_dict["Ak_7"].value.flatten(order="F"))
    par.Bk_minus_7 = list(param_dict["Bk_minus_7"].value.flatten(order="F"))
    par.Bk_plus_7 = list(param_dict["Bk_plus_7"].value.flatten(order="F"))
    par.Ak_8 = list(param_dict["Ak_8"].value.flatten(order="F"))
    par.Bk_minus_8 = list(param_dict["Bk_minus_8"].value.flatten(order="F"))
    par.Bk_plus_8 = list(param_dict["Bk_plus_8"].value.flatten(order="F"))
    par.Ak_9 = list(param_dict["Ak_9"].value.flatten(order="F"))
    par.Bk_minus_9 = list(param_dict["Bk_minus_9"].value.flatten(order="F"))
    par.Bk_plus_9 = list(param_dict["Bk_plus_9"].value.flatten(order="F"))
    par.Ak_10 = list(param_dict["Ak_10"].value.flatten(order="F"))
    par.Bk_minus_10 = list(param_dict["Bk_minus_10"].value.flatten(order="F"))
    par.Bk_plus_10 = list(param_dict["Bk_plus_10"].value.flatten(order="F"))
    par.Ak_11 = list(param_dict["Ak_11"].value.flatten(order="F"))
    par.Bk_minus_11 = list(param_dict["Bk_minus_11"].value.flatten(order="F"))
    par.Bk_plus_11 = list(param_dict["Bk_plus_11"].value.flatten(order="F"))
    par.Ak_12 = list(param_dict["Ak_12"].value.flatten(order="F"))
    par.Bk_minus_12 = list(param_dict["Bk_minus_12"].value.flatten(order="F"))
    par.Bk_plus_12 = list(param_dict["Bk_plus_12"].value.flatten(order="F"))
    par.Ak_13 = list(param_dict["Ak_13"].value.flatten(order="F"))
    par.Bk_minus_13 = list(param_dict["Bk_minus_13"].value.flatten(order="F"))
    par.Bk_plus_13 = list(param_dict["Bk_plus_13"].value.flatten(order="F"))
    par.x_0 = list(param_dict["x_0"].value.flatten(order="F"))
    par.x_ref = list(param_dict["x_ref"].value.flatten(order="F"))
    par.u_ref = list(param_dict["u_ref"].value.flatten(order="F"))

    # solve
    t0 = time.time()
    res = cpg_module.solve(upd, par)
    t1 = time.time()

    # store solution in problem object
    prob._clear_solution()
    prob.var_dict['U'].save_value(np.array(res.cpg_prim.U).reshape((3, 15), order='F'))
    prob.var_dict['var1376'].save_value(np.array(res.cpg_prim.var1376).reshape(2))
    prob.var_dict['V'].save_value(np.array(res.cpg_prim.V).reshape((7, 14), order='F'))
    prob.var_dict['v_0'].save_value(np.array(res.cpg_prim.v_0).reshape((7, 1), order='F'))
    prob.var_dict['v_N'].save_value(np.array(res.cpg_prim.v_N).reshape((6, 1), order='F'))
    prob.var_dict['eta'].save_value(np.array(res.cpg_prim.eta).reshape((1, 15), order='F'))
    prob.var_dict['X'].save_value(np.array(res.cpg_prim.X).reshape((7, 15), order='F'))
    prob.constraints[0].save_dual_value(np.array(res.cpg_dual.d0).reshape(7))
    prob.constraints[1].save_dual_value(np.array(res.cpg_dual.d1).reshape(7))
    prob.constraints[2].save_dual_value(np.array(res.cpg_dual.d2).reshape(7))
    prob.constraints[3].save_dual_value(np.array(res.cpg_dual.d3).reshape(7))
    prob.constraints[4].save_dual_value(np.array(res.cpg_dual.d4).reshape(7))
    prob.constraints[5].save_dual_value(np.array(res.cpg_dual.d5).reshape(7))
    prob.constraints[6].save_dual_value(np.array(res.cpg_dual.d6).reshape(7))
    prob.constraints[7].save_dual_value(np.array(res.cpg_dual.d7).reshape(7))
    prob.constraints[8].save_dual_value(np.array(res.cpg_dual.d8).reshape(7))
    prob.constraints[9].save_dual_value(np.array(res.cpg_dual.d9).reshape(7))
    prob.constraints[10].save_dual_value(np.array(res.cpg_dual.d10).reshape(7))
    prob.constraints[11].save_dual_value(np.array(res.cpg_dual.d11).reshape(7))
    prob.constraints[12].save_dual_value(np.array(res.cpg_dual.d12).reshape(7))
    prob.constraints[13].save_dual_value(np.array(res.cpg_dual.d13).reshape(7))
    prob.constraints[14].save_dual_value(np.array(res.cpg_dual.d14).reshape(15))
    prob.constraints[15].save_dual_value(np.array(res.cpg_dual.d15).reshape(15))
    prob.constraints[16].save_dual_value(np.array(res.cpg_dual.d16).reshape(15))
    prob.constraints[17].save_dual_value(np.array(res.cpg_dual.d17).reshape(15))
    prob.constraints[18].save_dual_value(np.array(res.cpg_dual.d18).reshape(15))
    prob.constraints[19].save_dual_value(np.array(res.cpg_dual.d19).reshape(15))
    prob.constraints[20].save_dual_value(np.array(res.cpg_dual.d20).reshape(15))
    prob.constraints[21].save_dual_value(np.array(res.cpg_dual.d21).reshape(2))
    prob.constraints[22].save_dual_value(np.array(res.cpg_dual.d22).reshape((7, 7), order='F'))
    prob.constraints[23].save_dual_value(np.array(res.cpg_dual.d23).reshape((2, 2), order='F'))
    prob.constraints[24].save_dual_value(np.array(res.cpg_dual.d24).reshape((2, 2), order='F'))
    prob.constraints[25].save_dual_value(np.array(res.cpg_dual.d25).reshape(1))
    prob.constraints[26].save_dual_value(np.array(res.cpg_dual.d26).reshape(1))
    prob.constraints[27].save_dual_value(np.array(res.cpg_dual.d27).reshape((1, 15), order='F'))

    # store additional solver information in problem object
    prob._status = "%d (for description visit https://qoco-org.github.io/qoco/)" % res.cpg_info.status
    if abs(res.cpg_info.obj_val) == 1e30:
        prob._value = np.sign(res.cpg_info.obj_val) * np.inf
    else:
        prob._value = res.cpg_info.obj_val
    primal_vars = {var.id: var.value for var in prob.variables()}
    dual_vars = {c.id: c.dual_value for c in prob.constraints}
    solver_specific_stats = {'obj_val': res.cpg_info.obj_val,
                             'status': prob._status,
                             'iter': res.cpg_info.iter,
                             'pri_res': res.cpg_info.pri_res,
                             'dua_res': res.cpg_info.dua_res,
                             'time': res.cpg_info.time}
    attr = {'solve_time': t1 - t0, 'solver_specific_stats': solver_specific_stats, 'num_iters': res.cpg_info.iter}
    prob._solution = Solution(prob.status, prob.value, primal_vars, dual_vars, attr)
    results_dict = {'solver_specific_stats': solver_specific_stats,
                    'num_iters': res.cpg_info.iter,
                    'solve_time': t1 - t0}
    prob._solver_stats = SolverStats.from_dict(results_dict, 'QOCO')

    return prob.value


def cpg_gradient(prob, gradient_sol_primal=None, gradient_sol_dual=None):

    # set gradient primal and dual solutions if provided
    gradient_sol = cpg_module.cpg_gsol()
    if gradient_sol_primal is not None and gradient_sol_dual is not None:
        gradient_sol.primal = list(gradient_sol_primal)
        gradient_sol.dual = list(gradient_sol_dual)
        use_sol = True
    else:
        gradient_sol.primal = [0] * 496
        gradient_sol.dual = [0] * 893
        use_sol = False

    # set variable deltas
    vdelta = cpg_module.cpg_vdelta()
    vdelta.U = list(prob.var_dict["U"].gradient.flatten(order="F"))
    vdelta.var1376 = list(prob.var_dict["var1376"].gradient.flatten(order="F"))
    vdelta.V = list(prob.var_dict["V"].gradient.flatten(order="F"))
    vdelta.v_0 = list(prob.var_dict["v_0"].gradient.flatten(order="F"))
    vdelta.v_N = list(prob.var_dict["v_N"].gradient.flatten(order="F"))
    vdelta.eta = list(prob.var_dict["eta"].gradient.flatten(order="F"))
    vdelta.X = list(prob.var_dict["X"].gradient.flatten(order="F"))
    pdelta = cpg_module.gradient(vdelta, gradient_sol, use_sol)
    prob.param_dict['Ak_0'].gradient = np.array(pdelta.Ak_0).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_0'].gradient = np.array(pdelta.Bk_minus_0).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_0'].gradient = np.array(pdelta.Bk_plus_0).reshape((7, 3), order='F')
    prob.param_dict['ck'].gradient = np.array(pdelta.ck).reshape((7, 14), order='F')
    prob.param_dict['Ak_1'].gradient = np.array(pdelta.Ak_1).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_1'].gradient = np.array(pdelta.Bk_minus_1).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_1'].gradient = np.array(pdelta.Bk_plus_1).reshape((7, 3), order='F')
    prob.param_dict['Ak_2'].gradient = np.array(pdelta.Ak_2).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_2'].gradient = np.array(pdelta.Bk_minus_2).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_2'].gradient = np.array(pdelta.Bk_plus_2).reshape((7, 3), order='F')
    prob.param_dict['Ak_3'].gradient = np.array(pdelta.Ak_3).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_3'].gradient = np.array(pdelta.Bk_minus_3).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_3'].gradient = np.array(pdelta.Bk_plus_3).reshape((7, 3), order='F')
    prob.param_dict['Ak_4'].gradient = np.array(pdelta.Ak_4).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_4'].gradient = np.array(pdelta.Bk_minus_4).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_4'].gradient = np.array(pdelta.Bk_plus_4).reshape((7, 3), order='F')
    prob.param_dict['Ak_5'].gradient = np.array(pdelta.Ak_5).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_5'].gradient = np.array(pdelta.Bk_minus_5).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_5'].gradient = np.array(pdelta.Bk_plus_5).reshape((7, 3), order='F')
    prob.param_dict['Ak_6'].gradient = np.array(pdelta.Ak_6).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_6'].gradient = np.array(pdelta.Bk_minus_6).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_6'].gradient = np.array(pdelta.Bk_plus_6).reshape((7, 3), order='F')
    prob.param_dict['Ak_7'].gradient = np.array(pdelta.Ak_7).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_7'].gradient = np.array(pdelta.Bk_minus_7).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_7'].gradient = np.array(pdelta.Bk_plus_7).reshape((7, 3), order='F')
    prob.param_dict['Ak_8'].gradient = np.array(pdelta.Ak_8).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_8'].gradient = np.array(pdelta.Bk_minus_8).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_8'].gradient = np.array(pdelta.Bk_plus_8).reshape((7, 3), order='F')
    prob.param_dict['Ak_9'].gradient = np.array(pdelta.Ak_9).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_9'].gradient = np.array(pdelta.Bk_minus_9).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_9'].gradient = np.array(pdelta.Bk_plus_9).reshape((7, 3), order='F')
    prob.param_dict['Ak_10'].gradient = np.array(pdelta.Ak_10).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_10'].gradient = np.array(pdelta.Bk_minus_10).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_10'].gradient = np.array(pdelta.Bk_plus_10).reshape((7, 3), order='F')
    prob.param_dict['Ak_11'].gradient = np.array(pdelta.Ak_11).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_11'].gradient = np.array(pdelta.Bk_minus_11).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_11'].gradient = np.array(pdelta.Bk_plus_11).reshape((7, 3), order='F')
    prob.param_dict['Ak_12'].gradient = np.array(pdelta.Ak_12).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_12'].gradient = np.array(pdelta.Bk_minus_12).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_12'].gradient = np.array(pdelta.Bk_plus_12).reshape((7, 3), order='F')
    prob.param_dict['Ak_13'].gradient = np.array(pdelta.Ak_13).reshape((7, 7), order='F')
    prob.param_dict['Bk_minus_13'].gradient = np.array(pdelta.Bk_minus_13).reshape((7, 3), order='F')
    prob.param_dict['Bk_plus_13'].gradient = np.array(pdelta.Bk_plus_13).reshape((7, 3), order='F')
    prob.param_dict['x_0'].gradient = np.array(pdelta.x_0).reshape((7, 1), order='F')
    prob.param_dict['x_ref'].gradient = np.array(pdelta.x_ref).reshape((7, 15), order='F')
    prob.param_dict['u_ref'].gradient = np.array(pdelta.u_ref).reshape((3, 15), order='F')


def forward(params, context):

    info = {}
    kwargs = context.solver_args.copy()
    prob = kwargs.pop("problem")
    parameters = prob.parameters()
    for pid, val in zip(context.param_ids, params):
        next(p for p in parameters if p.id == pid).value = val
    updated_params = kwargs.pop("updated_params", None)
    _, info["gradient_primal"], info["gradient_dual"] = cpg_solve_and_gradient_info(prob, updated_params, **kwargs)
    info["prob"] = prob

    vars = prob.variables()
    return [next(v for v in vars if v.id == variable.id).value for variable in context.variables], info


def backward(dvars, context):

    prob = context.info["prob"]
    vars = prob.variables()
    for variable, dv in zip(context.variables, dvars):
        next(v for v in vars if v.id == variable.id).gradient = dv
    gradient_primal = context.info["gradient_primal"]
    gradient_dual = context.info["gradient_dual"]
    cpg_gradient(prob, gradient_primal, gradient_dual)

    params = prob.parameters()
    return [next(p for p in params if p.id == pid).gradient for pid in context.param_ids], {}
